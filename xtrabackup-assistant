#!/usr/bin/env python3

import enum
import json
import os
import re
import shutil
import subprocess as sp
import sys
import tarfile
from argparse import ArgumentParser
from datetime import datetime
from rich.console import Console

NAME = 'Percona XtraBackup Assistant'
VERSION = 0.1
MIN_PYTHON_VERSION = (3, 9)
AUTHOR = 'Anton Samofal'

# CONFIG
BACKUPS_PATH = '/backups'
TEMP_DIR_PATH = '/tmp/xtrabackup'
XTRABACKUP_CONFIG_PATH = '/run/secrets/xtrabackup_config.json'


class Command(enum.Enum):
    CREATE = 'create'
    RESTORE = 'restore'


def main(command: Command):
    env = Environment()
    env.print_info()

    assistant = Assistant(env, Config())
    if command is Command.CREATE:
        assistant.create()
    elif command is Command.RESTORE:
        assistant.restore()


class Environment:
    def __init__(self):
        self.mysql_version = self._get_mysql_server_version()
        self.xtrabackup_version = self._get_xtrabackup_version()

    def print_info(self) -> None:
        tool_versions = (
            f"[green3]Percona MySQL Server {self.mysql_version}",
            f"[green3]Percona XtraBackup {self.xtrabackup_version}"
        )
        rprint(f"[blue][Environment][/blue]", ' | '.join(tool_versions))

    @staticmethod
    def _get_mysql_server_version() -> str:
        try:
            command = sp.run(['mysql', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            mysql_server_about = command.stdout.decode('utf-8')
            mysql_server_version_match = re.search(r'Ver (\S+) for Linux', mysql_server_about)
            if mysql_server_version_match is None:
                raise RuntimeError('Percona MySQL Server version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('Percona MySQL Server is missing!')

        return mysql_server_version_match.group(1)

    @staticmethod
    def _get_xtrabackup_version() -> str:
        try:
            command = sp.run(['xtrabackup', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            xtrabackup_about = command.stdout.decode('utf-8')
            xtrabackup_version_match = re.search(r'xtrabackup version (\S+) based on MySQL server', xtrabackup_about)
            if xtrabackup_version_match is None:
                raise RuntimeError('XtraBackup tool version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('XtraBackup tool is missing!')

        return xtrabackup_version_match.group(1)


class Config:
    def __init__(self):
        self.user = None
        self.password = None
        self.parallel = 10

        self.load_from_secrets()

    def load_from_secrets(self):
        try:
            with open(XTRABACKUP_CONFIG_PATH, 'r') as config_file:
                try:
                    config = json.load(config_file)
                except json.decoder.JSONDecodeError:
                    raise RuntimeError('Failed to parse the xtrabackup config. Is it valid JSON?')
        except FileNotFoundError:
            raise RuntimeError(f"Config file is missing: [default]/run/secrets/xtrabackup_config.json")

        # check for required options
        required_options = ('user', 'password')
        missing_required_options = tuple(
            filter(lambda required_option: required_option not in config, required_options)
        )
        if len(missing_required_options) > 0:
            raise RuntimeError(f"Config is missing required options: {', '.join(missing_required_options)}")

        # fill in config props
        for option, value in config.items():
            if hasattr(self, option):
                setattr(self, option, value)
            else:
                message = (
                    f"[yellow3]\\[Config][/yellow3]",
                    'Invalid xtrabackup config option:',
                    f"[red]{option}[/red].",
                    'Skipped.'
                )
                rprint(' '.join(message))

        rprint(f"[blue]\\[Config][/blue] [green3]XtraBackup config is ready.[/green3]")


class Assistant:
    def __init__(self, env: Environment, config: Config):
        self._env = env
        self._config = config

    def create(self) -> None:
        backup_timestamp = now('%Y-%m-%d_%H-%M')
        backup_file_name = f"{backup_timestamp}_inside_full_{self._env.mysql_version}"
        temp_backup_file_path = f"{TEMP_DIR_PATH}/{backup_file_name}.xbstream"
        temp_log_path = f"{TEMP_DIR_PATH}/xtrabackup.log"

        with open(temp_backup_file_path, 'wb') as backup_file, open(temp_log_path, 'w') as log_file:
            command_options = (
                '--backup',
                '--stream=xbstream',
                '--compress',
                f"--parallel={self._config.parallel}",
                '--compress-threads=5',
                f"--user={self._config.user}",
                f"--password={self._config.password}",
                '--host=127.0.0.1',
                f"--target-dir={TEMP_DIR_PATH}"
            )
            command = sp.Popen(['xtrabackup', *command_options], stdout=backup_file, stderr=sp.PIPE)
            for line in command.stderr:
                message = XtrabackupMessage(str(line, 'utf-8'))

                log_file.write(f"{message.formatted}\n")
                rprint(f"[blue][ExtraBackup][/blue] {message.formatted}")

            return_code = command.wait()

        if return_code != 0:
            log_path = f"/var/log/xtrabackup/{backup_timestamp}-error.log"
            shutil.move(temp_log_path, log_path)

            raise RuntimeError(f"Failed to create a backup! Error log: [default]{log_path}")

        # prepare a directory for today's backups
        backup_dir_path = f"{BACKUPS_PATH}/{now('%Y')}/{now('%m')}"
        if not os.path.exists(backup_dir_path):
            os.makedirs(backup_dir_path)

        # make an archive and put to the final dir
        rprint(f"[blue]\\[tar][/blue] [{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Creating archive...")
        backup_archive_path = f"{backup_dir_path}/{backup_file_name}.tar"
        with tarfile.open(backup_archive_path, "w") as tar:
            tar.add(temp_backup_file_path, arcname=os.path.basename(temp_backup_file_path))
            tar.add(temp_log_path, arcname=os.path.basename(temp_log_path))

        backup_size = f"{os.path.getsize(backup_archive_path) / float(1<<30):,.2f} GB"
        success_message = (
            f"[blue][Assistant][/blue]",
            f"[{now('%Y-%m-%d %H:%M:%S')}]",
            f"[green3]Backup successfully created:[/green3]",
            f"[magenta3]{backup_archive_path}",
            f"[yellow3]({backup_size})"
        )
        rprint(' '.join(success_message))

    @staticmethod
    def restore() -> None:
        rprint('restoring....')

    @staticmethod
    def clear_temp_dir():
        with os.scandir(TEMP_DIR_PATH) as entries:
            for entry in entries:
                if entry.is_dir() and not entry.is_symlink():
                    shutil.rmtree(entry.path)
                else:
                    os.remove(entry.path)

        version_check_log = f"/tmp/percona-version-check"
        if os.path.exists(version_check_log):
            os.remove(version_check_log)


class XtrabackupMessage:
    def __init__(self, message: str):
        self.original = message
        self.formatted = self._format()

    def _format(self) -> str:
        message = self.original.split()

        # format timestamp if this is ISO 8601 date at start
        try:
            message[0] = f"[{datetime.fromisoformat(message[0]).strftime('%Y-%m-%d %H:%M:%S')}]"
        except ValueError:
            # format timestamp if it's 'version_check' utility date at start
            version_check_timestamp = re.match(r'\d{6} \d{2}:\d{2}:\d{2}', self.original)
            if version_check_timestamp is not None:
                timestamp = datetime.strptime(version_check_timestamp.group(), '%y%m%d %H:%M:%S')
                message[0:2] = [f"[{timestamp.strftime('%Y-%m-%d %H:%M:%S')}]"]

        return ' '.join(message)


def parse_command() -> Command:
    """Register arguments from a command line"""
    parser = ArgumentParser(description=f"{NAME} v{VERSION}")
    parser.add_argument('--version', action='version', version=f"{NAME} v{VERSION}")

    subparsers = parser.add_subparsers(title='Available commands', required=True, dest='command')
    subparsers.add_parser(Command.CREATE.value, help='create database dump')
    subparsers.add_parser(Command.RESTORE.value, help='restore database dump')

    args = parser.parse_args()

    return Command(args.command)


def now(out_format: str) -> str:
    return datetime.now().strftime(out_format)


if __name__ == '__main__':
    # declare function for printing to the terminal
    console = Console(highlight=False)
    rprint = console.print

    if sys.version_info < MIN_PYTHON_VERSION:
        rprint("[red]Python %s.%s or newer is required." % MIN_PYTHON_VERSION)
        sys.exit(1)

    try:
        main(parse_command())
    except RuntimeError as error:
        rprint(f"[bright_red][Error] {error}")
        sys.exit(1)
    except KeyboardInterrupt:
        print('\rTerminating...')
        sys.exit(0)
    finally:
        Assistant.clear_temp_dir()
