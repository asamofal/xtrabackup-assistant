#!/usr/bin/env python3

import enum
import json
import os
import re
import shutil
import socket
import subprocess as sp
import sys
import tarfile
from argparse import ArgumentParser
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path, PurePath

import paramiko
from paramiko.ssh_exception import AuthenticationException, SSHException
from rich.console import Console
from rich.progress import Progress, TextColumn, BarColumn, SpinnerColumn, DownloadColumn, TransferSpeedColumn, \
    TaskProgressColumn

# META INFO
NAME = 'Percona XtraBackup Assistant'
VERSION = 0.1
AUTHOR = 'Anton Samofal'
MIN_PYTHON_VERSION = (3, 9)

# CONFIG
BACKUPS_PATH = '/backups'
TEMP_DIR_PATH = '/tmp/xtrabackup'
XTRABACKUP_CONFIG_PATH = '/run/secrets/xtrabackup_config.json'
# BACKUPS_PATH = './backups'
# TEMP_DIR_PATH = './tmp/xtrabackup'
# XTRABACKUP_CONFIG_PATH = './config.json'


class Command(enum.Enum):
    CREATE = 'create'
    RESTORE = 'restore'


def main(command: Command):
    env = Environment()
    env.print_info()

    config = Config.from_secrets()

    # create an archive asynchronously
    # try:
    #     def create_tar():
    #         backup_archive_path = Path('/backups/2022/07/2022-07-08_22-22_inside_full_8.0.28-19__.tar')
    #         with tarfile.open(backup_archive_path, 'w') as tar:
    #             temp_backup_file_path = Path('/backups/2022/07/2022-07-08_22-22_inside_full_8.0.28-19.tar')
    #             tar.add(temp_backup_file_path, arcname=temp_backup_file_path.name)
    #     tar_thread = threading.Thread(target=create_tar, name='tar_thread')
    #     tar_thread.start()
    # except KeyboardInterrupt:
    #     print('Interrupted!')
    #     sys.exit(0)

    # backup_path = Path('/backups/2022/07/2022-07-08_22-22_inside_full_8.0.28-19.tar')
    # backup_archive_path = Path('/backups/2022/07/backup_archive.tar')
    # with Progress(
    #         TextColumn('[blue]\\[tar][/blue]'),
    #         SpinnerColumn(),
    #         TextColumn("[progress.description]{task.description}"),
    #         BarColumn(),
    #         TaskProgressColumn(),
    #         transient=True
    # ) as progress:
    #     backup_size = backup_path.stat().st_size
    #
    #     try:
    #         with progress.open(backup_path, 'rb', description='[blue]Creating archive...') as backup:
    #             with tarfile.open(backup_archive_path, 'w') as tar:
    #                 file_info = tarfile.TarInfo(backup_path.name)
    #                 file_info.size = backup_size
    #                 tar.addfile(file_info, fileobj=backup)
    #     except KeyboardInterrupt:
    #         if os.path.exists(backup_archive_path):
    #             os.remove(backup_archive_path)
    #         raise KeyboardInterrupt
    #
    # exit(0)

    assistant = Assistant(env, config)
    if command is Command.CREATE:
        assistant.create()
    elif command is Command.RESTORE:
        assistant.restore()


class Environment:
    def __init__(self):
        self.mysql_version = self._get_mysql_server_version()
        self.xtrabackup_version = self._get_xtrabackup_version()

    def print_info(self) -> None:
        tool_versions = (
            f"[green3]Percona MySQL Server {self.mysql_version}",
            f"[green3]Percona XtraBackup {self.xtrabackup_version}"
        )
        rprint(f"[blue][Environment][/blue]", ' | '.join(tool_versions))

    @staticmethod
    def _get_mysql_server_version() -> str:
        try:
            command = sp.run(['mysql', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            mysql_server_about = command.stdout.decode('utf-8')
            mysql_server_version_match = re.search(r'Ver (\S+) for Linux', mysql_server_about)
            if mysql_server_version_match is None:
                raise RuntimeError('Percona MySQL Server version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('Percona MySQL Server is missing!')

        return mysql_server_version_match.group(1)

    @staticmethod
    def _get_xtrabackup_version() -> str:
        try:
            command = sp.run(['xtrabackup', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            xtrabackup_about = command.stdout.decode('utf-8')
            xtrabackup_version_match = re.search(r'xtrabackup version (\S+) based on MySQL server', xtrabackup_about)
            if xtrabackup_version_match is None:
                raise RuntimeError('XtraBackup tool version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('XtraBackup tool is missing!')

        return xtrabackup_version_match.group(1)


@dataclass(frozen=True)
class SftpConfig:
    host: str
    user: str
    password: str
    path: str = '/'


class Config:
    user: str = None
    password: str = None
    parallel: int = 10
    sftp: SftpConfig = None

    @staticmethod
    def from_secrets():
        self = Config()

        try:
            with open(XTRABACKUP_CONFIG_PATH, 'r') as config_file:
                try:
                    config = json.load(config_file)
                except json.decoder.JSONDecodeError:
                    raise RuntimeError('Failed to parse the xtrabackup config. Is it valid JSON?')
        except FileNotFoundError:
            raise RuntimeError(f"Config file is missing: [default]/run/secrets/xtrabackup_config.json")

        # check for required options
        required_options = ('user', 'password')
        missing_required_options = tuple(
            filter(lambda required_option: required_option not in config, required_options)
        )
        if len(missing_required_options) > 0:
            raise RuntimeError(f"Config is missing required options: [default]{', '.join(missing_required_options)}")

        # set sftp option
        if 'sftp' in config:
            sftp_config = config.pop('sftp')

            required_sftp_options = ('host', 'user', 'password')
            missing_required_sftp_options = tuple(
                filter(lambda required_option: required_option not in sftp_config, required_sftp_options)
            )
            if len(missing_required_sftp_options) > 0:
                raise RuntimeError(
                    f"SFTP config is missing required options: [default]{', '.join(missing_required_sftp_options)}"
                )

            self.sftp = SftpConfig(**sftp_config)

        # set config options
        for option, value in config.items():
            if hasattr(self, option):
                setattr(self, option, value)
            else:
                message = (
                    f"[yellow3]\\[Config][/yellow3]",
                    'Invalid xtrabackup config option:',
                    f"[red]{option}[/red].",
                    'Skipped.'
                )
                rprint(' '.join(message))

        rprint(f"[blue]\\[Config][/blue] XtraBackup config is ready.")

        return self


class SftpClient:
    def __init__(self, config: SftpConfig):
        try:
            self._config = config

            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            self.ssh_client.connect(hostname=config.host, username=config.user, password=config.password)
            self.sftp_client = self.ssh_client.open_sftp()
        except (SSHException, AuthenticationException, socket.error) as e:
            raise RuntimeError(f"Failed to init the SFTP connection: {e}")

    def upload(self, local_path: Path, remote_path: PurePath, display_progress=True):
        remote_dir_path = PurePath(str(remote_path.parent).lstrip('/'))
        self.mkdir_p(remote_dir_path)

        try:
            if display_progress:
                with Progress(
                    TextColumn('[blue][SFTP][/blue]'),
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    BarColumn(),
                    DownloadColumn(),
                    TransferSpeedColumn(),
                    transient=True
                ) as progress:
                    file_size = local_path.stat().st_size
                    uploading = progress.add_task("[blue]Uploading...", total=file_size)

                    self.sftp_client.put(
                        str(local_path),
                        str(remote_path),
                        lambda transferred, total: progress.update(uploading, completed=transferred)
                    )
            else:
                self.sftp_client.put(str(local_path), str(remote_path))
        except (EOFError, SSHException, KeyboardInterrupt):
            rprint('[blue][SFTP][/blue] [italic]Terminate signal received. Cleaning up....')
            # create a new connection as a socket of the current may be closed already
            with SftpClient(self._config) as sftp:
                sftp.delete(remote_path, ignore_errors=True)
                raise KeyboardInterrupt

    def delete(self, remote_path: PurePath, ignore_errors=False):
        try:
            self.sftp_client.remove(str(remote_path))
        except IOError as e:
            if ignore_errors is False:
                raise e

    def mkdir_p(self, remote_path: PurePath):
        """Make parent directories as needed"""
        dir_path = ''
        for dir_name in remote_path.parts:
            dir_path += f"/{dir_name}"
            try:
                self.sftp_client.listdir(dir_path)
            except IOError:
                self.sftp_client.mkdir(dir_path, 0o755)

    def close(self):
        if self.sftp_client is not None:
            self.sftp_client.close()

        if self.ssh_client is not None:
            self.ssh_client.close()

    def __enter__(self) -> "SftpClient":
        return self

    def __exit__(self, e_type, value, traceback):
        self.close()


class Assistant:
    def __init__(self, env: Environment, config: Config):
        self._env = env
        self._config = config

    def create(self) -> None:
        backup_timestamp = now('%Y-%m-%d_%H-%M')
        backup_file_name = f"{backup_timestamp}_inside_full_{self._env.mysql_version}"
        temp_backup_file_path = Path(f"{TEMP_DIR_PATH}/{backup_file_name}.xbstream")
        temp_log_path = Path(f"{TEMP_DIR_PATH}/xtrabackup.log")

        with open(temp_backup_file_path, 'wb') as backup_file, open(temp_log_path, 'w') as log_file:
            command_options = (
                '--backup',
                '--stream=xbstream',
                '--compress',
                f"--parallel={self._config.parallel}",
                '--compress-threads=5',
                f"--user={self._config.user}",
                f"--password={self._config.password}",
                '--host=127.0.0.1',
                f"--target-dir={TEMP_DIR_PATH}"
            )
            command = sp.Popen(['xtrabackup', *command_options], stdout=backup_file, stderr=sp.PIPE)
            for line in command.stderr:
                message = XtrabackupMessage(str(line, 'utf-8'))

                log_file.write(f"{message.formatted}\n")
                rprint(f"[blue][ExtraBackup][/blue] {message.formatted}")

            return_code = command.wait()

        if return_code != 0:
            log_path = Path(f"/var/log/xtrabackup/{backup_timestamp}-error.log")
            shutil.move(temp_log_path, log_path)

            raise RuntimeError(f"Failed to create a backup! Error log: [default]{str(log_path)}")

        # prepare a directory for today's backups
        backup_dir_path = f"{BACKUPS_PATH}/{now('%Y')}/{now('%m')}"
        if not os.path.exists(backup_dir_path):
            os.makedirs(backup_dir_path)

        # make an archive in the final dir
        backup_archive_path = Path(f"{backup_dir_path}/{backup_file_name}.tar")
        with Progress(
            TextColumn('[blue]\\[tar][/blue]'),
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            transient=True
        ) as progress:
            rprint(f"[blue]\\[tar][/blue] [{now('%Y-%m-%d %H:%M:%S')}] Start creating archive.")

            try:
                with progress.open(temp_backup_file_path, 'rb', description='[blue]Creating archive...') as backup:
                    with tarfile.open(backup_archive_path, 'w') as tar:
                        # add backup file
                        file_info = tarfile.TarInfo(temp_backup_file_path.name)
                        file_info.size = temp_backup_file_path.stat().st_size
                        tar.addfile(file_info, fileobj=backup)
                        # add log file
                        tar.add(temp_log_path, arcname=temp_log_path.name)
            except KeyboardInterrupt:
                if os.path.exists(backup_archive_path):
                    os.remove(backup_archive_path)
                if len(os.listdir(backup_archive_path.parent)) == 0:
                    os.rmdir(backup_archive_path.parent)

                raise KeyboardInterrupt

            rprint(f"[blue]\\[tar][/blue] [{now('%Y-%m-%d %H:%M:%S')}] Archive created.")

        backup_archive_size = backup_archive_path.stat().st_size
        success_message = (
            f"[blue][Assistant][/blue]",
            f"[{now('%Y-%m-%d %H:%M:%S')}]",
            f"[green3]Backup successfully created:[/green3]",
            f"[italic]{str(backup_archive_path)}",
            f"({backup_archive_size / float(1<<30):,.2f}GB)"
        )
        rprint(' '.join(success_message))

        if self._config.sftp is not None:
            with SftpClient(self._config.sftp) as sftp:
                rprint('[blue][SFTP][/blue] Connected to SFTP backups storage.')

                local_path = Path('/backups/2022/07/2022-07-07_13-07_inside_full_8.0.28-19.tar')
                remote_path = PurePath(f"{self._config.sftp.path}/{local_path.name}")
                sftp.upload(local_path, remote_path)

                rprint('[blue][SFTP][/blue] [green3]Dump successfully uploaded to SFTP backups storage!')

    @staticmethod
    def restore() -> None:
        rprint('restoring....')

    @staticmethod
    def clear_temp_dir():
        with os.scandir(TEMP_DIR_PATH) as entries:
            for entry in entries:
                if entry.is_dir() and not entry.is_symlink():
                    shutil.rmtree(entry.path)
                else:
                    os.remove(entry.path)

        version_check_log = f"/tmp/percona-version-check"
        if os.path.exists(version_check_log):
            os.remove(version_check_log)


class XtrabackupMessage:
    def __init__(self, message: str):
        self.original = message
        self.formatted = self._format()

    def _format(self) -> str:
        message = self.original.split()

        # format timestamp if this is ISO 8601 date at start
        try:
            message[0] = f"[{datetime.fromisoformat(message[0]).strftime('%Y-%m-%d %H:%M:%S')}]"
        except ValueError:
            # format timestamp if it's 'version_check' utility date at start
            version_check_timestamp = re.match(r'\d{6} \d{2}:\d{2}:\d{2}', self.original)
            if version_check_timestamp is not None:
                timestamp = datetime.strptime(version_check_timestamp.group(), '%y%m%d %H:%M:%S')
                message[0:2] = [f"[{timestamp.strftime('%Y-%m-%d %H:%M:%S')}]"]

        return ' '.join(message)


def parse_command() -> Command:
    """Register arguments from a command line"""
    parser = ArgumentParser(description=f"{NAME} v{VERSION}")
    parser.add_argument('--version', action='version', version=f"{NAME} v{VERSION}")

    subparsers = parser.add_subparsers(title='Available commands', required=True, dest='command')
    subparsers.add_parser(Command.CREATE.value, help='create database dump')
    subparsers.add_parser(Command.RESTORE.value, help='restore database dump')

    args = parser.parse_args()

    return Command(args.command)


def now(out_format: str) -> str:
    return datetime.now().strftime(out_format)


if __name__ == '__main__':
    # declare function for printing to the terminal
    console = Console(highlight=False)
    rprint = console.print

    if sys.version_info < MIN_PYTHON_VERSION:
        rprint("[red]Python %s.%s or newer is required." % MIN_PYTHON_VERSION)
        sys.exit(1)

    try:
        main(parse_command())
    except RuntimeError as error:
        rprint(f"[bright_red][Error] {error}")
        sys.exit(1)
    except KeyboardInterrupt:
        print('\rTerminating...')
        sys.exit(0)
    finally:
        Assistant.clear_temp_dir()
