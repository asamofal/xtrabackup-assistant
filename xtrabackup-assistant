#!/usr/bin/env python3

import enum
import re
import shutil
import subprocess as sp
import sys
from argparse import ArgumentParser
from datetime import datetime

from colorama import Fore as Color, init as init_colorama

NAME = 'Percona XtraBackup Assistant'
VERSION = 0.1
MIN_PYTHON_VERSION = (3, 9)
AUTHOR = 'Anton Samofal'

# CONFIG
BACKUPS_PATH = '/backups'


def main():
    try:
        env = Environment()
        env.print_info()

        assistant = Assistant(env)
        if assistant_command is Command.CREATE:
            assistant.create()
        elif assistant_command is Command.RESTORE:
            assistant.restore()

    except RuntimeError as error:
        sys.exit(f"{Color.RED}[Error] {error}")


class Environment:
    def __init__(self):
        self.mysql_version = self._get_mysql_server_version()
        self.xtrabackup_version = self._get_xtrabackup_version()

    def print_info(self) -> None:
        tool_versions = [
            f"{Color.GREEN}Percona MySQL Server {self.mysql_version}",
            f"{Color.GREEN}Percona XtraBackup {self.xtrabackup_version}"
        ]
        print(f"{Color.BLUE}[Environment]{Color.RESET}", ' | '.join(tool_versions))

    @staticmethod
    def _get_mysql_server_version() -> str:
        try:
            command = sp.run(['mysql', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            mysql_server_about = command.stdout.decode('utf-8')
            mysql_server_version_match = re.search(r'Ver (\S+) for Linux', mysql_server_about)
            if mysql_server_version_match is None:
                raise RuntimeError('Percona MySQL Server version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('Percona MySQL Server is missing!')

        return mysql_server_version_match.group(1)

    @staticmethod
    def _get_xtrabackup_version() -> str:
        try:
            command = sp.run(['xtrabackup', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            xtrabackup_about = command.stdout.decode('utf-8')
            xtrabackup_version_match = re.search(r'xtrabackup version (\S+) based on MySQL server', xtrabackup_about)
            if xtrabackup_version_match is None:
                raise RuntimeError('XtraBackup tool version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('XtraBackup tool is missing!')

        return xtrabackup_version_match.group(1)


class Assistant:
    def __init__(self, env: Environment):
        self._env = env

    def create(self) -> None:
        mysql_version = self._env.mysql_version
        date = datetime.now().strftime('%Y-%m-%d')
        date_time = datetime.now().strftime('%Y-%m-%d_%H-%M')

        # backup_dir_path = f"{BACKUPS_PATH}/{date}"
        # if not os.path.exists(backup_dir_path):
        #     os.makedirs(backup_dir_path)

        backup_file_name = f"{date_time}_inside_full_{mysql_version}.xbstream"
        temp_backup_file_path = f"/tmp/{backup_file_name}"
        temp_log_path = '/tmp/xtrabackup.log'

        with open(temp_backup_file_path, 'wb') as backup_file, open(temp_log_path, 'a') as log_file:
            command_options = [
                '--backup',
                '--stream=xbstream',
                '--compress',
                '--parallel=10',
                '--compress-threads=5',
                '--user=root',
                '--password=secret1',
                '--host=127.0.0.1',
                '--target-dir=/tmp'
            ]
            command = sp.Popen(['xtrabackup', *command_options], stdout=backup_file, stderr=sp.PIPE)
            for line in command.stderr:
                message = XtrabackupMessage(str(line, 'utf-8'))

                log_file.write(message.formatted)
                print(f"{Color.BLUE}[ExtraBackup]{Color.RESET} {message.formatted}")

            return_code = command.wait()

        if return_code != 0:
            log_path = f"/var/log/xtrabackup/{datetime}-error.log"
            shutil.move(temp_log_path, log_path)

            shutil.rmtree('/tmp')
            raise RuntimeError(f"Failed to create a backup! Error log: {log_path}")

        print(f"{Color.GREEN}Backup successfully created: {temp_backup_file_path}")

    @staticmethod
    def restore() -> None:
        print('restoring....')


class XtrabackupMessage:
    def __init__(self, message: str):
        self.original = message
        self.formatted = self._format()

    def _format(self) -> str:
        message = self.original.split()

        # format timestamp if this is ISO 8601 date at start
        try:
            message[0] = f"[{datetime.fromisoformat(message[0]).strftime('%Y-%m-%d %H:%M:%S')}]"
        except ValueError:
            # format timestamp if it's 'version_check' utility date at start
            version_check_timestamp = re.match(r'\d{6} \d{2}:\d{2}:\d{2}', self.original)
            if version_check_timestamp is not None:
                timestamp = datetime.strptime(version_check_timestamp.group(), '%y%m%d %H:%M:%S')
                message[0:2] = [f"[{timestamp.strftime('%Y-%m-%d %H:%M:%S')}]"]

        return ' '.join(message)


class Command(enum.Enum):
    CREATE = 'create'
    RESTORE = 'restore'


def parse_command() -> Command:
    """Parse arguments from a command line"""
    parser = ArgumentParser(description=f"{NAME} v{VERSION}")
    parser.add_argument('--version', action='version', version=f"{NAME} v{VERSION}")

    subparsers = parser.add_subparsers(title='Available commands', required=True, dest='command')
    subparsers.add_parser(Command.CREATE.value, help='create database dump')
    subparsers.add_parser(Command.RESTORE.value, help='restore database dump')

    args = parser.parse_args()

    return Command(args.command)


if __name__ == '__main__':
    # init colorama module
    init_colorama(autoreset=True)

    if sys.version_info < MIN_PYTHON_VERSION:
        sys.exit(f"{Color.RED}Python %s.%s or newer is required." % MIN_PYTHON_VERSION)

    assistant_command = parse_command()

    try:
        main()
    except KeyboardInterrupt:
        shutil.rmtree('/tmp')

        print(f'{Color.BLUE}Terminating...')

        sys.exit(0)
