#!/usr/bin/env python3
import os
from datetime import date
import enum
import sys
import subprocess as sp
import re
from argparse import ArgumentParser
from colorama import Fore as Color, Style, init as init_colorama

NAME = 'Percona XtraBackup Assistant'
VERSION = 0.1
MIN_PYTHON_VERSION = (3, 9)
AUTHOR = 'Anton Samofal'


def main():
    try:
        env = Environment()
        env.print_info()

        assistant = Assistant(env)
        if assistant_command is Command.CREATE:
            assistant.create()
        elif assistant_command is Command.RESTORE:
            assistant.restore()

    except RuntimeError as error:
        sys.exit(f"{Color.RED}{Style.BRIGHT}Error{Style.NORMAL}: {error}")


class Environment:
    def __init__(self):
        self.mysql_version = self._get_mysql_server_version()
        self.xtrabackup_version = self._get_xtrabackup_version()

    def print_info(self) -> None:
        tool_versions = [
            f"{Color.GREEN}Percona MySQL Server {self.mysql_version}",
            f"{Color.GREEN}Percona XtraBackup {self.xtrabackup_version}"
        ]
        print(f"{Color.BLUE}[Environment]{Color.RESET}", ' | '.join(tool_versions))

    @staticmethod
    def _get_mysql_server_version() -> str:
        try:
            command = sp.run(['mysql', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            mysql_server_about = command.stdout.decode('utf-8')
            mysql_server_version_match = re.search(r'Ver (\S+) for Linux', mysql_server_about)
            if mysql_server_version_match is None:
                raise RuntimeError('Percona MySQL Server version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('Percona MySQL Server is missing!')

        return mysql_server_version_match.group(1)

    @staticmethod
    def _get_xtrabackup_version() -> str:
        try:
            command = sp.run(['xtrabackup', '--version'], stdout=sp.PIPE, stderr=sp.STDOUT)
            xtrabackup_about = command.stdout.decode('utf-8')
            xtrabackup_version_match = re.search(r'xtrabackup version (\S+) based on MySQL server', xtrabackup_about)
            if xtrabackup_version_match is None:
                raise RuntimeError('XtraBackup tool version is not recognized!')
        except FileNotFoundError:
            raise RuntimeError('XtraBackup tool is missing!')

        return xtrabackup_version_match.group(1)


class Assistant:
    def __init__(self, env: Environment):
        self._env = env

    def create(self) -> None:
        mysql_version = self._env.mysql_version
        backup_name = f"{date.today()}_inside_full_{mysql_version}.xbstream"
        backup_path = f"/backups/{backup_name}"

        with open(backup_path, 'wb') as backup_file:
            command_options = [
                '--backup',
                '--stream=xbstream',
                '--compress',
                '--parallel=10',
                '--compress-threads=5',
                '--user=root',
                '--password=secret1',
                '--host=127.0.0.1',
                '--target-dir=/tmp'
            ]
            command = sp.Popen(['xtrabackup', *command_options], stdout=backup_file, stderr=sp.PIPE)
            for line in command.stderr:
                print(f"{Color.BLUE}[ExtraBackup]{Color.RESET}", str(line))

            return_code = command.wait()
            if return_code is not 0:
                os.remove(backup_path)

    def restore(self) -> None:
        print('restoring....')


class Command(enum.Enum):
    CREATE = 'create'
    RESTORE = 'restore'


def parse_command() -> Command:
    """Parse arguments from a command line"""
    parser = ArgumentParser(description=f"{NAME} v{VERSION}")
    parser.add_argument('--version', action='version', version=f"{NAME} v{VERSION}")

    subparsers = parser.add_subparsers(title='Available commands', required=True, dest='command')
    subparsers.add_parser(Command.CREATE.value, help='create database dump')
    subparsers.add_parser(Command.RESTORE.value, help='restore database dump')

    args = parser.parse_args()

    return Command(args.command)


if __name__ == '__main__':
    # init colorama module
    init_colorama(autoreset=True)

    if sys.version_info < MIN_PYTHON_VERSION:
        sys.exit(f"{Color.RED}Python %s.%s or newer is required." % MIN_PYTHON_VERSION)

    assistant_command = parse_command()

    try:
        main()
    except KeyboardInterrupt:
        print('')
        sys.exit(0)
